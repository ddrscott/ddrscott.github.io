<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sql | @_ddrscott_]]></title>
  <link href="http://ddrscott.github.io/blog/categories/sql/atom.xml" rel="self"/>
  <link href="http://ddrscott.github.io/"/>
  <updated>2017-03-08T11:22:49-06:00</updated>
  <id>http://ddrscott.github.io/</id>
  <author>
    <name><![CDATA[Scott Pierce]]></name>
    <email><![CDATA[ddrscott@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What the SQL? - Lateral Joins]]></title>
    <link href="http://ddrscott.github.io/blog/2017/what-the-sql-lateral/"/>
    <updated>2017-03-08T12:30:00-06:00</updated>
    <id>http://ddrscott.github.io/blog/2017/what-the-sql-lateral</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/what_the_sql_lateral.png" title="&lsquo;What the SQL?!? Lateral Joins&rsquo;" ></p>

<h1>What the SQL?!? &ndash; Lateral Joins</h1>

<p>Today&rsquo;s &ldquo;What the SQL?!?&rdquo; features the keyword <code>LATERAL</code>. A prerequisite to
understanding lateral joins are regular joins and subqueries. I&rsquo;ll explain those
briefly to see how <code>LATERAL</code> can simplify a complicated SQL query.</p>

<!-- more -->


<p>Please note, our target database is PostgreSQL. These examples may work with
other databases, but might need some massaging to get them to work properly.
Search online for the specific vendor&rsquo;s documentation if errors pop up.
Try searching for &ldquo;lateral joins &rdquo;. Not all database vendors
support the keyword <code>LATERAL</code>.</p>

<h2>A Problem to Solve</h2>

<p>We have a table with system uptimes. The table records a start timestamp and an
end timestamp. If the service is still running, the end timestamp is left null
because it hasn&rsquo;t ended. We want a query to display an overview this data.</p>

<p>Our final solution will return a row per day and 24 columns containing an uptime
percentage for each hour in the day. It will look like the following.</p>

<p><code>
  cal_date  | hour_0 | hour_1 | hour_2 | hour_3 | ... | hour_21 | hour_22 | hour_23
------------+--------+--------+--------+--------+-----+---------+---------+---------
 2017-03-01 |      0 |   0.75 |   0.25 |      0 | ... |       0 |       0 |       0
 2017-03-02 |      0 |      0 |      0 |      0 | ... |       1 |       1 |       1
(2 rows)
</code></p>

<p>Please note we&rsquo;ll use <code>...</code> abbreviate some of the results. All queries are
schema independent and should be copy/paste-able into any <code>psql</code> session.</p>

<h2>Sample Uptime Data</h2>

<p>The sample uptime data is derived from a virtual table built from the following query:</p>

<p><code>sql
SELECT
  *
FROM (
  VALUES
  ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
  ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
  ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></p>

<p>The data looks like:</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 2017-03-02 19:00:00 |
(3 rows)
```</p>

<p>We want to plot the time against a time sliced table representing all the
effective hours in the uptime window. We&rsquo;ll make use of another virtual table to
build up all the time slices:</p>

<p>```sql
SELECT</p>

<pre><code>start_ts,
start_ts + interval '1 hour' AS end_ts
</code></pre>

<p>FROM generate_series(&lsquo;2017-03-01&rsquo;::date,</p>

<pre><code>                 '2017-03-03'::timestamp - interval '1 hour',
                 interval '1 hour'
                ) AS t(start_ts)
</code></pre>

<p>```</p>

<p>This we make use of PostgreSQL&rsquo;s <a href="https://www.postgresql.org/docs/9.3/static/functions-srf.html">generate_series</a>
to return all the hours between a time range. The data looks like:</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 00:00:00 | 2017-03-01 01:00:00
 2017-03-01 01:00:00 | 2017-03-01 02:00:00
 2017-03-01 02:00:00 | 2017-03-01 03:00:00
 &mdash; &hellip; many more rows &hellip;
 2017-03-01 03:00:00 | 2017-03-01 04:00:00
 2017-03-02 22:00:00 | 2017-03-02 23:00:00
 2017-03-02 23:00:00 | 2017-03-03 00:00:00
(48 rows)
```</p>

<h2>Left Join</h2>

<p>We use a left join to glue together overlapping time ranges between these two
data sets. We want all the data on the <code>LEFT</code> side in the <code>FROM</code> clause to return
regardless of an uptime record existing within its time slice.</p>

<p>```sql
SELECT</p>

<pre><code>*
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
  start_ts,
  start_ts + interval '1 hour' AS end_ts
FROM generate_series(
       '2017-03-01'::date,
       '2017-03-03'::timestamp - interval '1 hour',
       interval '1 hour'
) AS t(start_ts)
</code></pre>

<p>) AS cal
LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
  VALUES
  ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
  ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
  ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
```</p>

<p>The result set shows we have some variety in our sample data. With 3 slices
up time and 3 slices of downtime.</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts        |      start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 00:00:00 | 2017-03-01 01:00:00 |                     |
 2017-03-01 01:00:00 | 2017-03-01 02:00:00 | 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 02:00:00 | 2017-03-01 03:00:00 | 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 03:00:00 | 2017-03-01 04:00:00 |                     |
 &hellip;
 2017-03-01 07:00:00 | 2017-03-01 08:00:00 |                     |
 2017-03-01 08:00:00 | 2017-03-01 09:00:00 | 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 &hellip;
 2017-03-01 20:00:00 | 2017-03-01 21:00:00 | 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 2017-03-01 21:00:00 | 2017-03-01 22:00:00 |                     |
 &hellip;
 2017-03-02 18:00:00 | 2017-03-02 19:00:00 |                     |
 2017-03-02 19:00:00 | 2017-03-02 20:00:00 | 2017-03-02 19:00:00 |
 &hellip;
 2017-03-02 23:00:00 | 2017-03-03 00:00:00 | 2017-03-02 19:00:00 |
(48 rows)
```</p>

<p>If we try without the <code>LEFT</code> clause, we&rsquo;ll only see 20 rows containing the up slices.</p>

<h2>Time to compute some timing</h2>

<p>Let&rsquo;s add some times and sensible column names and replace the <code>*</code></p>

<p>```sql
SELECT</p>

<pre><code>-- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
```</p>

<p>```plain</p>

<pre><code>  first_ts       |       last_ts       |  cal_date  | cal_hour | cal_seconds
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<pre><code>                 | 2017-03-01 01:00:00 | 2017-03-01 |        0 |        3600
</code></pre>

<p> 2017-03-01 01:15:00 | 2017-03-01 02:00:00 | 2017-03-01 |        1 |        3600
 2017-03-01 02:00:00 | 2017-03-01 02:15:00 | 2017-03-01 |        2 |        3600</p>

<pre><code>                 | 2017-03-01 04:00:00 | 2017-03-01 |        3 |        3600
                 | 2017-03-01 05:00:00 | 2017-03-01 |        4 |        3600
                 | 2017-03-01 06:00:00 | 2017-03-01 |        5 |        3600
                 | 2017-03-01 07:00:00 | 2017-03-01 |        6 |        3600
                 | 2017-03-01 08:00:00 | 2017-03-01 |        7 |        3600
</code></pre>

<p> 2017-03-01 08:00:00 | 2017-03-01 09:00:00 | 2017-03-01 |        8 |        3600
 &hellip;
 2017-03-01 20:00:00 | 2017-03-01 20:00:00 | 2017-03-01 |       20 |        3600</p>

<pre><code>                 | 2017-03-01 22:00:00 | 2017-03-01 |       21 |        3600
</code></pre>

<p> &hellip;</p>

<pre><code>                 | 2017-03-02 19:00:00 | 2017-03-02 |       18 |        3600
</code></pre>

<p> 2017-03-02 19:00:00 | 2017-03-02 20:00:00 | 2017-03-02 |       19 |        3600
 &hellip;
 2017-03-02 23:00:00 | 2017-03-03 00:00:00 | 2017-03-02 |       23 |        3600
(48 rows)
```</p>

<h2>Subquery, Subquery, What&rsquo;s the Worry?</h2>

<p>SQL is all about nested subqueries. It&rsquo;s hard to escape without creating
views, but who has time to lookup that <a href="https://www.postgresql.org/docs/9.3/static/sql-createview.html">syntax</a>
<em>and</em> get their <a href="https://imgflip.com/i/1kzzyn">DBA&rsquo;s</a> permission to run the DDL?!?</p>

<p>Let&rsquo;s add some duration times to the result set. We&rsquo;ll use the traditional sub
query for it.</p>

<p>```sql
SELECT</p>

<pre><code>-- calculate uptime seconds
coalesce(
  extract(epoch FROM age(last_ts, first_ts)),
  0
) AS up_seconds,
*
</code></pre>

<p>FROM (</p>

<pre><code>SELECT
    -- will use `first_ts` and `last_ts` to calculate uptime duration
    CASE WHEN uptime.start_ts IS NOT NULL THEN
        greatest(uptime.start_ts, cal.start_ts)
    END                                               AS first_ts,
    least(cal.end_ts, uptime.end_ts)                  AS last_ts,
    date_trunc('day', cal.start_ts)::date             AS cal_date,
    extract(hour from cal.start_ts)                   AS cal_hour,
    extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
FROM (
    -- build virtual table of all hours between
    -- a date range
    SELECT
        start_ts,
        start_ts + interval '1 hour' AS end_ts
        FROM generate_series('2017-03-01'::date,
                             '2017-03-03'::timestamp - interval '1 hour',
                             interval '1 hour'
        ) AS t(start_ts)
) AS cal
LEFT JOIN (
    -- build virtual table of uptimes
    SELECT *
    FROM (
        VALUES
        ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
        ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
        ('2017-03-02 19:00:00-06', null)
    ) AS t(start_ts, end_ts)
) AS uptime ON cal.end_ts &gt; uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
</code></pre>

<p>) t1
```</p>

<p>```plain</p>

<h2> up_seconds</h2>

<pre><code>      0
   2700
    900
      0
      0
</code></pre>

<p>&hellip;</p>

<pre><code>   3600
</code></pre>

<p>(48 rows)
```</p>

<p>Without the subquery we&rsquo;d be getting into even more nested function calls and
would have to double compute values or have no visibility in the intermediate
steps. We could have calculated <code>up_seconds</code> directly in the first query which
introduced <code>first_ts</code> and <code>last_ts</code>. That would look like this:</p>

<p>```sql
SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM
        age(
            least(cal.end_ts, uptime.end_ts), 
            CASE WHEN uptime.start_ts IS NOT NULL THEN
              greatest(uptime.start_ts, cal.start_ts)
            END
        )
    ),
    0
) AS up_seconds
</code></pre>

<p>FROM &mdash;&ndash; &hellip;
```</p>

<p>It&rsquo;s not for the weak stomach, but frankly speaking, neither is the subquery&hellip;</p>

<h2>Enough Nesting, <code>LATERAL</code> join save me!</h2>

<p>Lateral joins can give us the best of both worlds: reduced subquery nesting and
traceable computed values. We&rsquo;re going to move the initial computed values like
<code>first_ts</code> and <code>last_ts</code>, move them to a virtual table then <code>JOIN LATERAL</code> so
they can get their own table alias. We&rsquo;ll do it again for <code>up_seconds</code> and use
<code>first_ts</code> and <code>last_ts</code> from its sibling table.</p>

<p>```sql
SELECT</p>

<pre><code>t2.up_seconds
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
JOIN LATERAL (
  SELECT</p>

<pre><code>  -- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>) t1 ON true
JOIN LATERAL (
  &mdash; calculate uptime seconds for the time slice
  SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM age(last_ts, first_ts)),
    0
) AS up_seconds
</code></pre>

<p>) t2 ON true
```</p>

<p>This gives us the same results but without the deep nesting.</p>

<p>```plain</p>

<h2> up_seconds</h2>

<pre><code>      0
   2700
    900
      0
      0
   3600
</code></pre>

<p>&hellip;</p>

<pre><code>   3600
</code></pre>

<p>(48 rows)
```</p>

<p>What&rsquo;s great about this strategy is we can quickly choose which columns to see
as we build up the query.</p>

<p>```sql
SELECT
  t2.up_seconds
  &hellip;</p>

<p>&mdash; or &mdash;</p>

<p>SELECT
  t2.<em>,
  t1.</em>
```</p>

<p>Let&rsquo;s build up the final calculation using the same strategy:</p>

<p>```sql
SELECT
  t2.<em>,
  t3.</em>
FROM &hellip;
JOIN LATERAL (
  &mdash; calculate percentage between uptime seconds and available seconds
  &mdash; within the time slice
  SELECT</p>

<pre><code>up_seconds / cal_seconds AS up_pct
</code></pre>

<p>) t3 ON true
```</p>

<p>```plain
 up_seconds | up_pct
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      0 |      0
   2700 |   0.75
    900 |   0.25
      0 |      0
</code></pre>

<p>&hellip;</p>

<pre><code>   3600 |      1
</code></pre>

<p>(48 rows)
```</p>

<h2>Plot the Hours</h2>

<p>Now we have all the computed data we need. Let&rsquo;s plot it as a cross tab (but not
actually use <a href="https://www.postgresql.org/docs/9.3/static/tablefunc.html"><code>crosstab</code></a>)</p>

<p>We&rsquo;ll need to consolidate the long list of data by <code>cal_date</code> and pivot the
<code>cal_hour</code> as a column and <code>up_pct</code> as a value. In case of overlapping uptimes
we&rsquo;ll be pessimists and choose the lowest or <code>min</code> uptime percentage.</p>

<p>The final query looks like:</p>

<p>```sql
SELECT</p>

<pre><code>cal_date,
max(CASE WHEN cal_hour = 0 THEN up_pct  END) AS hour_0,
max(CASE WHEN cal_hour = 1 THEN up_pct  END) AS hour_1,
max(CASE WHEN cal_hour = 2 THEN up_pct  END) AS hour_2,
max(CASE WHEN cal_hour = 3 THEN up_pct  END) AS hour_3,
max(CASE WHEN cal_hour = 4 THEN up_pct  END) AS hour_4,
max(CASE WHEN cal_hour = 5 THEN up_pct  END) AS hour_5,
max(CASE WHEN cal_hour = 6 THEN up_pct  END) AS hour_6,
max(CASE WHEN cal_hour = 7 THEN up_pct  END) AS hour_7,
max(CASE WHEN cal_hour = 8 THEN up_pct  END) AS hour_8,
max(CASE WHEN cal_hour = 9 THEN up_pct  END) AS hour_9,
max(CASE WHEN cal_hour = 10 THEN up_pct END) AS hour_10,
max(CASE WHEN cal_hour = 11 THEN up_pct END) AS hour_11,
max(CASE WHEN cal_hour = 12 THEN up_pct END) AS hour_12,
max(CASE WHEN cal_hour = 13 THEN up_pct END) AS hour_13,
max(CASE WHEN cal_hour = 14 THEN up_pct END) AS hour_14,
max(CASE WHEN cal_hour = 15 THEN up_pct END) AS hour_15,
max(CASE WHEN cal_hour = 16 THEN up_pct END) AS hour_16,
max(CASE WHEN cal_hour = 17 THEN up_pct END) AS hour_17,
max(CASE WHEN cal_hour = 18 THEN up_pct END) AS hour_18,
max(CASE WHEN cal_hour = 19 THEN up_pct END) AS hour_19,
max(CASE WHEN cal_hour = 20 THEN up_pct END) AS hour_20,
max(CASE WHEN cal_hour = 21 THEN up_pct END) AS hour_21,
max(CASE WHEN cal_hour = 22 THEN up_pct END) AS hour_22,
max(CASE WHEN cal_hour = 23 THEN up_pct END) AS hour_23
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
JOIN LATERAL (
  SELECT</p>

<pre><code>  -- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>) t1 ON true
JOIN LATERAL (
  SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM age(last_ts, first_ts)),
    0
) AS up_seconds
</code></pre>

<p>) t2 ON true
JOIN LATERAL (
  &mdash; calculate percentage between uptime seconds and available seconds
  &mdash; within the time slice
  SELECT
  up_seconds / cal_seconds AS up_pct
) t3 ON true
GROUP BY cal_date
```</p>

<p><code>plain
  cal_date  | hour_0 | hour_1 | hour_2 | hour_3 | ... | hour_23
------------+--------+--------+--------+--------+ ... +---------
 2017-03-01 |      0 |   0.75 |   0.25 |      0 | ... |       0
 2017-03-02 |      0 |      0 |      0 |      0 | ... |       1
(2 rows)
</code></p>

<h1>More than CTE and Cross Join</h1>

<p>This example only scratches the surface of <code>LATERAL</code>s super powers. On the
surface <code>LATERAL</code> can do things <code>CTE</code>, cross join, and <code>WINDOW</code> can do.
PostgreSQL describe <code>LATERAL</code> as:</p>

<blockquote><p>Subqueries appearing in FROM can be preceded by the key word LATERAL.
This allows them to reference columns provided by preceding FROM items.
(Without LATERAL, each subquery is evaluated independently and so cannot
cross-reference any other FROM item.)</p></blockquote>

<p>TL;DR &ndash; <code>LATERAL</code> allows subqueries to reference earlier tables.</p>

<h1>References</h1>

<ul>
<li><a href="https://www.postgresql.org/docs/9.6/static/queries-table-expressions.html#QUERIES-LATERAL">Postgres Lateral Joins</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
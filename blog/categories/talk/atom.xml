<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: talk | @_ddrscott_]]></title>
  <link href="http://ddrscott.github.io/blog/categories/talk/atom.xml" rel="self"/>
  <link href="http://ddrscott.github.io/"/>
  <updated>2017-04-12T00:59:37-05:00</updated>
  <id>http://ddrscott.github.io/</id>
  <author>
    <name><![CDATA[Scott Pierce]]></name>
    <email><![CDATA[ddrscott@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim Send Text]]></title>
    <link href="http://ddrscott.github.io/blog/2017/vim-send-text/"/>
    <updated>2017-04-10T13:30:00-05:00</updated>
    <id>http://ddrscott.github.io/blog/2017/vim-send-text</id>
    <content type="html"><![CDATA[<p><img class="featured <a" src="href="https://raw.githubusercontent.com/ddrscott/vim-islime2/gh-pages/demo.gif">https://raw.githubusercontent.com/ddrscott/vim-islime2/gh-pages/demo.gif</a>" title="&lsquo;Vim Send Text Demo&rsquo;" ></p>

<p>After pairing with some Sublime users, I noticed a neat feature. Or more
accurately, they were rubbing it in my face that their cute editor was better
than mine. The feature was <a href="https://github.com/wch/SendText">SendText</a>. Well, I
couldn&rsquo;t let Sublime users have all the fun, and apparently neither could a few
other people.</p>

<!-- more -->


<h2>History</h2>

<p>There have been a few other implementations at this feature. These
implementations sent the text to a screen or tmux split. Since I don&rsquo;t use
either, I couldn&rsquo;t use them a la carte.</p>

<ul>
<li><a href="https://github.com/vim-scripts/tslime.vim">https://github.com/vim-scripts/tslime.vim</a></li>
<li><a href="https://github.com/jpalardy/vim-slime">https://github.com/jpalardy/vim-slime</a></li>
<li><a href="https://github.com/ervandew/screen">https://github.com/ervandew/screen</a></li>
</ul>


<p>This next implementation was good. It&rsquo;s only flaw, IMHO, was it&rsquo;s mappings and
naming. The naming &ldquo;ISlime2&rdquo; is impossible for me to type on the first try. The
mappings overlapped my existing mappings.
<a href="https://github.com/matschaffer/vim-islime2">ISlime2</a> did all the hard work
AppleScript work and provides the Vim function to pass into the AppleScript.</p>

<p>Enter <a href="https://github.com/ddrscott/vim-sendtext">vim-sendtext</a>.
<a href="https://github.com/ddrscott/vim-sendtext">vim-sendtext</a> is a fork of <a href="https://github.com/matschaffer/vim-islime2">ISlime2</a>.
My fork removes all the mappings, exposes useful internal functions, and adds
recommended mappings to the README.md.</p>

<h2>Recommended Mappings</h2>

<p>```vim</p>

<p>&ldquo; Send current line
nnoremap <silent> <Leader>i<CR> :SendTextCurrentLine<CR></p>

<p>&ldquo; Send in/around text object &ndash; operation pending
nnoremap <silent> <Leader>i :set opfunc=sendtext#iTermSendOperator<CR>g@</p>

<p>&ldquo; Send visual selection
vnoremap <silent> <Leader>i :&lt;C-u>call sendtext#iTermSendOperator(visualmode(), 1)<CR></p>

<p>&ldquo; Move to next line then send it
nnoremap <silent> <Leader>ij :SendTextNextLine<CR></p>

<p>&ldquo; Move to previous line then send it
nnoremap <silent> <Leader>ik :SendTextPreviousLine<CR>
```</p>

<h2>Vim Operator Pending</h2>

<p>One of the main reasons to use Vim is Operator pending.  It&rsquo;s at the heart of
<code>vip</code>, <code>dip</code>, <code>ciw</code>, etc.
<a href="https://github.com/ddrscott/vim-sendtext">vim-sendtext</a> provides an operator
pending function so we can logically do <code>{SEND}ap</code>, <code>{SEND}ip</code>, <code>{SEND}if</code>, etc.
The identical function works in visual mode to help build confidence in our text
object targets.</p>

<p>To read more about operator pending functions and how to create them try:
<code>vim
:h map-operator
</code></p>

<h2>Conclusion</h2>

<p>Hope <a href="https://github.com/ddrscott/vim-sendtext">vim-sendtext</a> can remove some
feature envy from Sublime. Happy console hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What the SQL?!? WINDOW]]></title>
    <link href="http://ddrscott.github.io/blog/2017/what-the-sql-window/"/>
    <updated>2017-03-22T13:30:00-05:00</updated>
    <id>http://ddrscott.github.io/blog/2017/what-the-sql-window</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/what_the_sql_window.png" width="1079" height="369" title="&lsquo;What the SQL?!?  WINDOW&rsquo;" ></p>

<p>Today&rsquo;s &ldquo;What the SQL?!?&rdquo; features the keyword <code>WINDOW</code>. This clause allows
us to elegantly select results from the previous results from the previous results
from the previous results&hellip;</p>

<!-- more -->


<p>Please note, our target database is PostgreSQL. These examples may work with
other databases, but might need some massaging to get them to work properly.
Search online for the specific vendor&rsquo;s documentation if errors pop up.
Try searching for &ldquo;WINDOW queries &rdquo;. Not all database vendors
support the keyword <code>WINDOW</code>.</p>

<h2>Create Sample Data</h2>

<p>```sql
DROP TABLE IF EXISTS sample_moves;
CREATE TABLE sample_moves AS
  SELECT</p>

<pre><code>column1::int     AS id,
column2::varchar AS name,
column3::varchar AS address,
column4::date AS moved_at
</code></pre>

<p>  FROM (</p>

<pre><code>VALUES
  (1, 'Alice' , '1 Main St', '2017-01-01'),
  (2, 'Bob'   , '2 Main St', '2017-02-01'),
  (3, 'Cat'   , '2 Main St', '2017-03-01'),
  (4, 'Dan Sr'  , '3 Main St',  '1970-04-01'),
  (5, 'Dan Jr'  , '3 Main St',  '2001-04-01'),
  (6, 'Dan 3rd' , '3 Main St', '2017-04-01')
</code></pre>

<p>  ) as t
;</p>

<p>CREATE INDEX ON sample_moves(address);</p>

<p>SELECT * FROM sample_moves;
```</p>

<h4>Results:</h4>

<table>
<thead>
<tr>
<th></th>
<th> id </th>
<th>  name   </th>
<th>  address  </th>
<th>  moved_at</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1 </td>
<td> Alice   </td>
<td> 1 Main St </td>
<td> 2017-01-01</td>
</tr>
<tr>
<td></td>
<td>  2 </td>
<td> Bob     </td>
<td> 2 Main St </td>
<td> 2017-02-01</td>
</tr>
<tr>
<td></td>
<td>  3 </td>
<td> Cat     </td>
<td> 2 Main St </td>
<td> 2017-03-01</td>
</tr>
<tr>
<td></td>
<td>  4 </td>
<td> Dan Sr  </td>
<td> 3 Main St </td>
<td> 1970-04-01</td>
</tr>
<tr>
<td></td>
<td>  5 </td>
<td> Dan Jr  </td>
<td> 3 Main St </td>
<td> 2001-04-01</td>
</tr>
<tr>
<td></td>
<td>  6 </td>
<td> Dan 3rd </td>
<td> 3 Main St </td>
<td> 2017-04-01</td>
</tr>
</tbody>
</table>


<h2>Life Without Windows</h2>

<p>A quick poem&hellip;</p>

<blockquote><p>Eyes big and wide,     <br/>
nothing seen inside.   <br/>
Feeling around         <br/>
nothing abound.        <br/>
This things wet,       <br/>
toxic I bet.           <br/>
Closing my eyes,       <br/>
still can&rsquo;t rest.      <br/>
Having a window,       <br/>
would be best.         <br/></p></blockquote>

<h3>How many people live at each address?</h3>

<p>Using a standard <code>GROUP BY</code> with <code>COUNT</code> we consolidate the records and count
how many rows belong to each address.</p>

<blockquote><p><strong>Tip</strong>: <code>COUNT(1)</code> is more efficient than <code>COUNT(*)</code>.</p></blockquote>

<p><code>sql
SELECT
  address,
  COUNT(1) total
FROM sample_moves
GROUP BY address
ORDER BY address;
</code></p>

<h4>Results:</h4>

<table>
<thead>
<tr>
<th></th>
<th>  address  </th>
<th> total</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> 1 Main St </td>
<td>     1</td>
</tr>
<tr>
<td></td>
<td> 2 Main St </td>
<td>     2</td>
</tr>
<tr>
<td></td>
<td> 3 Main St </td>
<td>     3</td>
</tr>
</tbody>
</table>


<h3>How many people live with each person?</h3>

<p>Enter subquery land. Life without windows is not exciting.</p>

<p>```sql
SELECT
  *,
  (</p>

<pre><code>SELECT
  -- everyone at the address, minus the person
  COUNT(1) - 1
FROM sample_moves t2
WHERE t2.address = t1.address
</code></pre>

<p>  ) AS others
FROM sample_moves t1;
```</p>

<h4>Results:</h4>

<table>
<thead>
<tr>
<th></th>
<th> id </th>
<th>  name   </th>
<th>  address  </th>
<th>  moved_at  </th>
<th> others</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1 </td>
<td> Alice   </td>
<td> 1 Main St </td>
<td> 2017-01-01 </td>
<td>      0</td>
</tr>
<tr>
<td></td>
<td>  2 </td>
<td> Bob     </td>
<td> 2 Main St </td>
<td> 2017-02-01 </td>
<td>      1</td>
</tr>
<tr>
<td></td>
<td>  3 </td>
<td> Cat     </td>
<td> 2 Main St </td>
<td> 2017-03-01 </td>
<td>      1</td>
</tr>
<tr>
<td></td>
<td>  4 </td>
<td> Dan Sr  </td>
<td> 3 Main St </td>
<td> 1970-04-01 </td>
<td>      2</td>
</tr>
<tr>
<td></td>
<td>  5 </td>
<td> Dan Jr  </td>
<td> 3 Main St </td>
<td> 2001-04-01 </td>
<td>      2</td>
</tr>
<tr>
<td></td>
<td>  6 </td>
<td> Dan 3rd </td>
<td> 3 Main St </td>
<td> 2017-04-01 </td>
<td>      2</td>
</tr>
</tbody>
</table>


<h3><code>JOIN</code> works, too</h3>

<p>```sql
SELECT
  t1.*,
  t2.others
FROM sample_moves t1
JOIN (
  SELECT</p>

<pre><code>address,
COUNT(1) - 1 as others
</code></pre>

<p>  FROM sample_moves
  GROUP BY address
  ORDER BY address
) t2 USING (address);
```</p>

<h3>And so does <code>JOIN LATERAL</code></h3>

<p>```sql
SELECT
  t1.*,
  t2.others
FROM sample_moves t1
JOIN LATERAL (
  SELECT</p>

<pre><code>address,
COUNT(1) - 1 as others
</code></pre>

<p>  FROM sample_moves sub
  WHERE sub.address = t1.address
  GROUP BY address
  ORDER BY address
) t2 ON true;
```</p>

<h3>That&rsquo;s nice, but who moved in first?</h3>

<p>```sql
SELECT
  *,
  (</p>

<pre><code>SELECT
  COUNT(1) - 1
FROM sample_moves t2
WHERE t2.address = t1.address
</code></pre>

<p>  ) AS others,
  (</p>

<pre><code>SELECT
  name
FROM sample_moves t3
WHERE t3.address = t1.address
ORDER BY moved_at ASC
LIMIT 1
</code></pre>

<p>  ) AS first_person
FROM sample_moves t1;
```</p>

<h2>Wait I thought this was about windows?!?</h2>

<p>The keyword <code>OVER</code> is the gateway drug into <code>WINDOW</code> functions. Using <code>OVER</code>
with parenthesis is an inline window. The <code>PARTITION BY</code> keywords gives similar
functionality to <code>GROUP BY</code> and <code>JOIN ... USING</code> all in one power packed
statement. It can never reduce the number of records in a result set which is
the same behavior expected of a correlated subquery.</p>

<p><code>PARTITION BY</code> is treated the same as the traditional <code>GROUP BY</code>. The <code>ORDER BY</code>
also has the same behavior as its use in a standard query.</p>

<p><code>sql
SELECT
  *,
  (count(1) OVER (PARTITION BY address)) - 1                      AS others,
  first_value(name) OVER (PARTITION BY address ORDER BY moved_at) AS first_moved
FROM sample_moves;
</code></p>

<h4>Results</h4>

<table>
<thead>
<tr>
<th></th>
<th> id </th>
<th>  name   </th>
<th>  address  </th>
<th>  moved_at  </th>
<th> others </th>
<th> first_moved</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1 </td>
<td> Alice   </td>
<td> 1 Main St </td>
<td> 2017-01-01 </td>
<td>      0 </td>
<td> Alice</td>
</tr>
<tr>
<td></td>
<td>  2 </td>
<td> Bob     </td>
<td> 2 Main St </td>
<td> 2017-02-01 </td>
<td>      1 </td>
<td> Bob</td>
</tr>
<tr>
<td></td>
<td>  3 </td>
<td> Cat     </td>
<td> 2 Main St </td>
<td> 2017-03-01 </td>
<td>      1 </td>
<td> Bob</td>
</tr>
<tr>
<td></td>
<td>  4 </td>
<td> Dan Sr  </td>
<td> 3 Main St </td>
<td> 1970-04-01 </td>
<td>      2 </td>
<td> Dan Sr</td>
</tr>
<tr>
<td></td>
<td>  5 </td>
<td> Dan Jr  </td>
<td> 3 Main St </td>
<td> 2001-04-01 </td>
<td>      2 </td>
<td> Dan Sr</td>
</tr>
<tr>
<td></td>
<td>  6 </td>
<td> Dan 3rd </td>
<td> 3 Main St </td>
<td> 2017-04-01 </td>
<td>      2 </td>
<td> Dan Sr</td>
</tr>
</tbody>
</table>


<p>A picture with arrows worth a thousand words:</p>

<p><img class="featured" src="/images/window_arrows.png" width="988" height="391" title="&lsquo;Window SQL with arrows&rsquo;" ></p>

<h2>That doesn&rsquo;t look very DRY. Finally, a <code>WINDOW</code></h2>

<p>The <code>WINDOW</code> keyword allows us to alias the options of the <code>OVER</code> clause. Namely
the expression <code>(...)</code> between and including the parenthesis.</p>

<p>In the following example we add the use of <code>RANGE</code> to provide additional
direction to the windowing clause.</p>

<p><code>sql
SELECT
  *,
  (count(1) OVER w) - 1 AS others,
  first_value(name) OVER w AS first_moved,
  last_value(name)  OVER w AS last_moved
FROM sample_moves
WINDOW w AS (
  PARTITION BY address ORDER BY moved_at
  RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
);
</code></p>

<h4>Results</h4>

<table>
<thead>
<tr>
<th></th>
<th> id </th>
<th>  name   </th>
<th>  address  </th>
<th>  moved_at  </th>
<th> others </th>
<th> first_moved </th>
<th> last_moved</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>  1 </td>
<td> Alice   </td>
<td> 1 Main St </td>
<td> 2017-01-01 </td>
<td>      0 </td>
<td> Alice       </td>
<td> Alice</td>
</tr>
<tr>
<td></td>
<td>  2 </td>
<td> Bob     </td>
<td> 2 Main St </td>
<td> 2017-02-01 </td>
<td>      0 </td>
<td> Bob         </td>
<td> Bob</td>
</tr>
<tr>
<td></td>
<td>  3 </td>
<td> Cat     </td>
<td> 2 Main St </td>
<td> 2017-03-01 </td>
<td>      1 </td>
<td> Bob         </td>
<td> Cat</td>
</tr>
<tr>
<td></td>
<td>  4 </td>
<td> Dan Sr  </td>
<td> 3 Main St </td>
<td> 1970-04-01 </td>
<td>      0 </td>
<td> Dan Sr      </td>
<td> Dan Sr</td>
</tr>
<tr>
<td></td>
<td>  5 </td>
<td> Dan Jr  </td>
<td> 3 Main St </td>
<td> 2001-04-01 </td>
<td>      1 </td>
<td> Dan Sr      </td>
<td> Dan Jr</td>
</tr>
<tr>
<td></td>
<td>  6 </td>
<td> Dan 3rd </td>
<td> 3 Main St </td>
<td> 2017-04-01 </td>
<td>      2 </td>
<td> Dan Sr      </td>
<td> Dan 3rd</td>
</tr>
</tbody>
</table>


<p><code>sql
-- Previous and Next Record
SELECT
  *,
  (count(1) OVER w) - 1 AS others,
  first_value(name) OVER w AS first_moved,
  last_value(name)  OVER w AS last_moved,
  lag(id) OVER (ORDER BY id) AS prev_id,
  lead(id) OVER (ORDER BY id) AS next_id
FROM sample_moves
WINDOW w AS (
  PARTITION BY address
  ORDER BY moved_at
  RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
ORDER BY address;
</code></p>

<h4>Results</h4>

<table>
<thead>
<tr>
<th></th>
<th>  id </th>
<th>  name   </th>
<th>  address  </th>
<th>  moved_at  </th>
<th> others </th>
<th> first_moved </th>
<th> last_moved </th>
<th> prev_id </th>
<th> next_id</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>   1 </td>
<td> Alice   </td>
<td> 1 Main St </td>
<td> 2017-01-01 </td>
<td>      0 </td>
<td> Alice       </td>
<td> Alice      </td>
<td>         </td>
<td>       2</td>
</tr>
<tr>
<td></td>
<td>   2 </td>
<td> Bob     </td>
<td> 2 Main St </td>
<td> 2017-02-01 </td>
<td>      1 </td>
<td> Bob         </td>
<td> Cat        </td>
<td>       1 </td>
<td>       3</td>
</tr>
<tr>
<td></td>
<td>   3 </td>
<td> Cat     </td>
<td> 2 Main St </td>
<td> 2017-03-01 </td>
<td>      1 </td>
<td> Bob         </td>
<td> Cat        </td>
<td>       2 </td>
<td>       4</td>
</tr>
<tr>
<td></td>
<td>   4 </td>
<td> Dan Sr  </td>
<td> 3 Main St </td>
<td> 1970-04-01 </td>
<td>      2 </td>
<td> Dan Sr      </td>
<td> Dan 3rd    </td>
<td>       3 </td>
<td>       5</td>
</tr>
<tr>
<td></td>
<td>   5 </td>
<td> Dan Jr  </td>
<td> 3 Main St </td>
<td> 2001-04-01 </td>
<td>      2 </td>
<td> Dan Sr      </td>
<td> Dan 3rd    </td>
<td>       4 </td>
<td>       6</td>
</tr>
<tr>
<td></td>
<td>   6 </td>
<td> Dan 3rd </td>
<td> 3 Main St </td>
<td> 2017-04-01 </td>
<td>      2 </td>
<td> Dan Sr      </td>
<td> Dan 3rd    </td>
<td>       5 </td>
<td></td>
</tr>
</tbody>
</table>


<h1>List Window Functions</h1>

<p>Here is a list from <a href="https://www.postgresql.org/docs/9.3/static/functions-window.html">Postgres docs</a>
of all the window functions. In addition to these, <em>any regular aggregate function</em> can be use within a window.</p>

<table>
<thead>
<tr>
<th></th>
<th> Function        </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> row_number()    </td>
<td> number of the current row within its partition, counting from 1 </td>
</tr>
<tr>
<td></td>
<td> rank()          </td>
<td> rank of the current row with gaps; same as row_number of its first peer </td>
</tr>
<tr>
<td></td>
<td> dense_rank()    </td>
<td> rank of the current row without gaps; this function counts peer groups </td>
</tr>
<tr>
<td></td>
<td> percent_rank()  </td>
<td> relative rank of the current row: (rank - 1) / (total rows &ndash; 1) </td>
</tr>
<tr>
<td></td>
<td> cume_dist()     </td>
<td> relative rank of the current row: (number of rows preceding or peer with current row) / (total rows) </td>
</tr>
<tr>
<td></td>
<td> ntile           </td>
<td> integer ranging from 1 to the argument value, dividing the partition as equally as possible </td>
</tr>
<tr>
<td></td>
<td> lag()           </td>
<td> returns value evaluated at the row that is offset rows before the current row within the partition; if there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null </td>
</tr>
<tr>
<td></td>
<td> lead()          </td>
<td> returns value evaluated at the row that is offset rows after the current row within the partition; if there is no such row, instead return default (which must be of the same type as value). Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null </td>
</tr>
<tr>
<td></td>
<td> first_value()   </td>
<td> returns value evaluated at the row that is the first row of the window frame </td>
</tr>
<tr>
<td></td>
<td> last_value()    </td>
<td> returns value evaluated at the row that is the last row of the window frame </td>
</tr>
<tr>
<td></td>
<td> nth_value()     </td>
<td> returns value evaluated at the row that is the nth row of the window frame (counting from 1); null if no such row </td>
</tr>
</tbody>
</table>


<h1>References</h1>

<ul>
<li>Postgres Window Tutorial: <a href="https://www.postgresql.org/docs/9.3/static/tutorial-window.html">https://www.postgresql.org/docs/9.3/static/tutorial-window.html</a></li>
<li>Postgres Window Functions: <a href="https://www.postgresql.org/docs/9.3/static/functions-window.html">https://www.postgresql.org/docs/9.3/static/functions-window.html</a></li>
<li>Postgres Window Syntax: <a href="https://www.postgresql.org/docs/9.3/static/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">https://www.postgresql.org/docs/9.3/static/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What the SQL?!? Recursive]]></title>
    <link href="http://ddrscott.github.io/blog/2017/what-the-sql-recursive/"/>
    <updated>2017-03-15T13:30:00-05:00</updated>
    <id>http://ddrscott.github.io/blog/2017/what-the-sql-recursive</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/i_heart_recursion.png" width="1804" height="1195" title="&lsquo;What the SQL?!? Recursive&rsquo;" ></p>

<p>Today&rsquo;s &ldquo;What the SQL?!?&rdquo; features the keyword <code>RECURSIVE</code>. This clause allows
us to elegantly select results from the previous results from the previous results
from the previous results&hellip;</p>

<!-- more -->


<p>Please note, our target database is PostgreSQL. These examples may work with
other databases, but might need some massaging to get them to work properly.
Search online for the specific vendor&rsquo;s documentation if errors pop up.
Try searching for &ldquo;RECURSIVE queries &rdquo;. Not all database vendors
support the keyword <code>RECURSIVE</code>.</p>

<h2>Fibonacci Sequence</h2>

<p>According to <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Wikipedia</a>:</p>

<blockquote><p>In mathematics, the Fibonacci numbers are the numbers in the following integer
sequence, called the Fibonacci sequence, and characterized by the fact that
every number after the first two is the sum of the two preceding ones:</p>

<pre><code>1, 1, 2, 3, 5, 8, 13, 21, 34, 55 ...
</code></pre></blockquote>

<h2>SQL Solution</h2>

<p>Our SQL solution will make use of the <code>RECURSIVE</code> <a href="https://www.postgresql.org/docs/9.3/static/queries-with.html">CTE</a>
keyword.</p>

<p>```sql
WITH RECURSIVE t(i, fi, fib) AS (
  SELECT</p>

<pre><code>1,
0::NUMERIC,
1::NUMERIC
</code></pre>

<p>  UNION ALL
  SELECT</p>

<pre><code>i + 1,
fib,
fi + fib
</code></pre>

<p>  FROM t
  WHERE i &lt; 10
)
SELECT
  i,
  fib
FROM t
```</p>

<h2>The Ins and Outs</h2>

<p>Here&rsquo;s some inline colorful comments to explain the sections:
<img class="featured" src="/images/recursion_sql.png" width="1563" height="998" title="&lsquo;annotated SQL&rsquo;" ></p>

<p>Maybe arrows will help a little more with the flow of data:
<img class="featured" src="/images/recursive_query.jpg" width="1024" height="705" title="&lsquo;Data Flow&rsquo;" ></p>

<h2>Fibonacci Results</h2>

<p>When you run the query, you&rsquo;ll get the following results:</p>

<p>```
 i  | fib
&mdash;&mdash;+&mdash;&mdash;&ndash;
  1 |   1
  2 |   1
  3 |   2
  4 |   3
  5 |   5
  6 |   8
  7 |  13
  8 |  21
  9 |  34
 10 |  55</p>

<p>(10 rows)
```</p>

<p>If you want to see the results for a high number, update <code>i &lt; 10</code> to a higher
value. If you go above <code>i &lt; 793</code>, Postgres gives up and returns <code>Nan</code> which means
<code>Not a number</code> which means the computed value is larger than your computer can
handle and still treat like a number. Sorry, get a new computer or work with
numbers less than 166 digits long.</p>

<h1>A Real World Example with Hierarchical Data</h1>

<p>Fibonacci sequence is nice and all, but you have real data concerns. You&rsquo;re
thinking, &ldquo;Show me the DATA!&rdquo;. So here&rsquo;s the data&hellip;</p>

<p><code>``sql
-- Build</code>sample_people` table
CREATE TABLE sample_people AS
  SELECT</p>

<pre><code>column1::int     AS id,
column2::varchar AS name,
column3::int     AS parent_id
</code></pre>

<p>  FROM (</p>

<pre><code>VALUES
  (0, 'Root' , null),
  (1, 'Alice', 0),
  (2, 'Bob'  , 1),
  (3, 'Cat'  , 1),
  (4, 'Dan'  , 3),
  (5, 'Evan' , 0),
  (6, 'Frank', 5)
</code></pre>

<p>  ) as t
  ;</p>

<p>SELECT * FROM sample_people;
&mdash;  id | name  | parent_id
&mdash; &mdash;&mdash;+&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
&mdash;   0 | Root  |
&mdash;   1 | Alice |         0
&mdash;   2 | Bob   |         1
&mdash;   3 | Cat   |         1
&mdash;   4 | Dan   |         3
&mdash;   5 | Evan  |         0
&mdash;   6 | Frank |         5
```</p>

<p>Our <code>sample_people</code> table represents a person by name and that person may have a
parent. The parent of all the parents is <code>Root</code>.</p>

<p>And finally our recursive query to get a nice display of the hierarchy.</p>

<p><code>``sql
WITH RECURSIVE tree --</code>tree` is the table alias.</p>

<pre><code>                -- It must be used as part of the `UNION` statement.
</code></pre>

<p>  AS (
  &mdash; 1) Initialize table with all the top level rows.
  &mdash;    Anything without a parent is a parent. Is that apparent?
  SELECT</p>

<pre><code>0 AS level,        -- 2) Set the level to 0.
sample_people.*    -- 3) Return the initial row
</code></pre>

<p>  FROM sample_people
  WHERE parent_id = 0  &mdash; 4) Top level doesn&rsquo;t have a parent.
  UNION ALL
  &mdash; 5) Union all the parents with their children.
  SELECT</p>

<pre><code>tree.level + 1,    -- 6) Increment the level every time we loop.
sample_people.*    -- 7) Return the current row - the child row. 
</code></pre>

<p>  FROM tree    &mdash; 8) <code>tree</code> is populated with the previous results.</p>

<pre><code>           --    Every loop gets a new record from current result.
</code></pre>

<p>  JOIN sample_people ON sample_people.parent_id = tree.id
)
SELECT
  repeat(&lsquo; &rsquo;, level * 4) || name AS display
FROM tree
ORDER BY level, name
;</p>

<p>&mdash;    display</p>

<hr />

<p>&mdash;  Alice
&mdash;  Evan
&mdash;      Bob
&mdash;      Cat
&mdash;      Frank
&mdash;          Dan
&mdash; (6 rows)
```</p>

<h1>Bait and Switch</h1>

<p><code>RECURSIVE</code> is not actually recursive. It isn&rsquo;t a function calling itself.
Sorry, not sorry. It&rsquo;s much closer to a <code>while</code> loop. Here&rsquo;s what Postgres has to say about it:</p>

<blockquote><p>Note: Strictly speaking, this process is <strong>iteration</strong> not recursion, but RECURSIVE
is the terminology chosen by the SQL standards committee. [emphasis added]</p></blockquote>

<h1>Closing</h1>

<p>So the next time you try to crawl a hierarchy of data, we hope <code>RECURSIVE</code> comes
to mind. It&rsquo;s a great way to save round trips to the database and query what is
needed based on the data&rsquo;s structure. Think of all the nested subqueries we can
save together!</p>

<h1>References</h1>

<ul>
<li>Postgres WITH Queries: <a href="https://www.postgresql.org/docs/9.3/static/queries-with.html">https://www.postgresql.org/docs/9.3/static/queries-with.html</a></li>
<li>Wikipedia Fibonacci number: <a href="https://en.wikipedia.org/wiki/Fibonacci_number">https://en.wikipedia.org/wiki/Fibonacci_number</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What the SQL?!? Lateral Joins]]></title>
    <link href="http://ddrscott.github.io/blog/2017/what-the-sql-lateral/"/>
    <updated>2017-03-08T12:30:00-06:00</updated>
    <id>http://ddrscott.github.io/blog/2017/what-the-sql-lateral</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/what_the_sql_lateral.png" title="&lsquo;What the SQL?!? Lateral Joins&rsquo;" ></p>

<p>Today&rsquo;s &ldquo;What the SQL?!?&rdquo; features the keyword <code>LATERAL</code>. A prerequisite to
understanding lateral joins are regular joins and subqueries. I&rsquo;ll explain those
briefly to see how <code>LATERAL</code> can simplify a complicated SQL query.</p>

<!-- more -->


<p>Please note, our target database is PostgreSQL. These examples may work with
other databases, but might need some massaging to get them to work properly.
Search online for the specific vendor&rsquo;s documentation if errors pop up.
Try searching for &ldquo;lateral joins &rdquo;. Not all database vendors
support the keyword <code>LATERAL</code>.</p>

<h2>A Problem to Solve</h2>

<p>We have a table with system uptimes. The table records a start timestamp and an
end timestamp. If the service is still running, the end timestamp is left null
because it hasn&rsquo;t ended. We want a query to display an overview this data.</p>

<p>Our final solution will return a row per day and 24 columns containing an uptime
percentage for each hour in the day. It will look like the following.</p>

<p><code>
  cal_date  | hour_0 | hour_1 | hour_2 | hour_3 | ... | hour_21 | hour_22 | hour_23
------------+--------+--------+--------+--------+-----+---------+---------+---------
 2017-03-01 |      0 |   0.75 |   0.25 |      0 | ... |       0 |       0 |       0
 2017-03-02 |      0 |      0 |      0 |      0 | ... |       1 |       1 |       1
(2 rows)
</code></p>

<p>Please note we&rsquo;ll use <code>...</code> abbreviate some of the results. All queries are
schema independent and should be copy/paste-able into any <code>psql</code> session.</p>

<h2>Sample Uptime Data</h2>

<p>The sample uptime data is derived from a virtual table built from the following query:</p>

<p><code>sql
SELECT
  *
FROM (
  VALUES
  ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
  ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
  ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></p>

<p>The data looks like:</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 2017-03-02 19:00:00 |
(3 rows)
```</p>

<p>We want to plot the time against a time sliced table representing all the
effective hours in the uptime window. We&rsquo;ll make use of another virtual table to
build up all the time slices:</p>

<p>```sql
SELECT</p>

<pre><code>start_ts,
start_ts + interval '1 hour' AS end_ts
</code></pre>

<p>FROM generate_series(&lsquo;2017-03-01&rsquo;::date,</p>

<pre><code>                 '2017-03-03'::timestamp - interval '1 hour',
                 interval '1 hour'
                ) AS t(start_ts)
</code></pre>

<p>```</p>

<p>This we make use of PostgreSQL&rsquo;s <a href="https://www.postgresql.org/docs/9.3/static/functions-srf.html">generate_series</a>
to return all the hours between a time range. The data looks like:</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 00:00:00 | 2017-03-01 01:00:00
 2017-03-01 01:00:00 | 2017-03-01 02:00:00
 2017-03-01 02:00:00 | 2017-03-01 03:00:00
 &mdash; &hellip; many more rows &hellip;
 2017-03-01 03:00:00 | 2017-03-01 04:00:00
 2017-03-02 22:00:00 | 2017-03-02 23:00:00
 2017-03-02 23:00:00 | 2017-03-03 00:00:00
(48 rows)
```</p>

<h2>Left Join</h2>

<p>We use a left join to glue together overlapping time ranges between these two
data sets. We want all the data on the <code>LEFT</code> side in the <code>FROM</code> clause to return
regardless of an uptime record existing within its time slice.</p>

<p>```sql
SELECT</p>

<pre><code>*
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
  start_ts,
  start_ts + interval '1 hour' AS end_ts
FROM generate_series(
       '2017-03-01'::date,
       '2017-03-03'::timestamp - interval '1 hour',
       interval '1 hour'
) AS t(start_ts)
</code></pre>

<p>) AS cal
LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
  VALUES
  ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
  ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
  ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
```</p>

<p>The result set shows we have some variety in our sample data. With 3 slices
up time and 3 slices of downtime.</p>

<p>```plain</p>

<pre><code>  start_ts       |       end_ts        |      start_ts       |       end_ts
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
 2017-03-01 00:00:00 | 2017-03-01 01:00:00 |                     |
 2017-03-01 01:00:00 | 2017-03-01 02:00:00 | 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 02:00:00 | 2017-03-01 03:00:00 | 2017-03-01 01:15:00 | 2017-03-01 02:15:00
 2017-03-01 03:00:00 | 2017-03-01 04:00:00 |                     |
 &hellip;
 2017-03-01 07:00:00 | 2017-03-01 08:00:00 |                     |
 2017-03-01 08:00:00 | 2017-03-01 09:00:00 | 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 &hellip;
 2017-03-01 20:00:00 | 2017-03-01 21:00:00 | 2017-03-01 08:00:00 | 2017-03-01 20:00:00
 2017-03-01 21:00:00 | 2017-03-01 22:00:00 |                     |
 &hellip;
 2017-03-02 18:00:00 | 2017-03-02 19:00:00 |                     |
 2017-03-02 19:00:00 | 2017-03-02 20:00:00 | 2017-03-02 19:00:00 |
 &hellip;
 2017-03-02 23:00:00 | 2017-03-03 00:00:00 | 2017-03-02 19:00:00 |
(48 rows)
```</p>

<p>If we try without the <code>LEFT</code> clause, we&rsquo;ll only see 20 rows containing the up slices.</p>

<h2>Time to compute some timing</h2>

<p>Let&rsquo;s add some times and sensible column names and replace the <code>*</code></p>

<p>```sql
SELECT</p>

<pre><code>-- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
```</p>

<p>```plain</p>

<pre><code>  first_ts       |       last_ts       |  cal_date  | cal_hour | cal_seconds
</code></pre>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p>

<pre><code>                 | 2017-03-01 01:00:00 | 2017-03-01 |        0 |        3600
</code></pre>

<p> 2017-03-01 01:15:00 | 2017-03-01 02:00:00 | 2017-03-01 |        1 |        3600
 2017-03-01 02:00:00 | 2017-03-01 02:15:00 | 2017-03-01 |        2 |        3600</p>

<pre><code>                 | 2017-03-01 04:00:00 | 2017-03-01 |        3 |        3600
                 | 2017-03-01 05:00:00 | 2017-03-01 |        4 |        3600
                 | 2017-03-01 06:00:00 | 2017-03-01 |        5 |        3600
                 | 2017-03-01 07:00:00 | 2017-03-01 |        6 |        3600
                 | 2017-03-01 08:00:00 | 2017-03-01 |        7 |        3600
</code></pre>

<p> 2017-03-01 08:00:00 | 2017-03-01 09:00:00 | 2017-03-01 |        8 |        3600
 &hellip;
 2017-03-01 20:00:00 | 2017-03-01 20:00:00 | 2017-03-01 |       20 |        3600</p>

<pre><code>                 | 2017-03-01 22:00:00 | 2017-03-01 |       21 |        3600
</code></pre>

<p> &hellip;</p>

<pre><code>                 | 2017-03-02 19:00:00 | 2017-03-02 |       18 |        3600
</code></pre>

<p> 2017-03-02 19:00:00 | 2017-03-02 20:00:00 | 2017-03-02 |       19 |        3600
 &hellip;
 2017-03-02 23:00:00 | 2017-03-03 00:00:00 | 2017-03-02 |       23 |        3600
(48 rows)
```</p>

<h2>Subquery, Subquery, What&rsquo;s the Worry?</h2>

<p>SQL is all about nested subqueries. It&rsquo;s hard to escape without creating
views, but who has time to lookup that <a href="https://www.postgresql.org/docs/9.3/static/sql-createview.html">syntax</a>
<em>and</em> get their <a href="https://imgflip.com/i/1kzzyn">DBA&rsquo;s</a> permission to run the DDL?!?</p>

<p>Let&rsquo;s add some duration times to the result set. We&rsquo;ll use the traditional sub
query for it.</p>

<p>```sql
SELECT</p>

<pre><code>-- calculate uptime seconds
coalesce(
  extract(epoch FROM age(last_ts, first_ts)),
  0
) AS up_seconds,
*
</code></pre>

<p>FROM (</p>

<pre><code>SELECT
    -- will use `first_ts` and `last_ts` to calculate uptime duration
    CASE WHEN uptime.start_ts IS NOT NULL THEN
        greatest(uptime.start_ts, cal.start_ts)
    END                                               AS first_ts,
    least(cal.end_ts, uptime.end_ts)                  AS last_ts,
    date_trunc('day', cal.start_ts)::date             AS cal_date,
    extract(hour from cal.start_ts)                   AS cal_hour,
    extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
FROM (
    -- build virtual table of all hours between
    -- a date range
    SELECT
        start_ts,
        start_ts + interval '1 hour' AS end_ts
        FROM generate_series('2017-03-01'::date,
                             '2017-03-03'::timestamp - interval '1 hour',
                             interval '1 hour'
        ) AS t(start_ts)
) AS cal
LEFT JOIN (
    -- build virtual table of uptimes
    SELECT *
    FROM (
        VALUES
        ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
        ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
        ('2017-03-02 19:00:00-06', null)
    ) AS t(start_ts, end_ts)
) AS uptime ON cal.end_ts &gt; uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
</code></pre>

<p>) t1
```</p>

<p>```plain</p>

<h2> up_seconds</h2>

<pre><code>      0
   2700
    900
      0
      0
</code></pre>

<p>&hellip;</p>

<pre><code>   3600
</code></pre>

<p>(48 rows)
```</p>

<p>Without the subquery we&rsquo;d be getting into even more nested function calls and
would have to double compute values or have no visibility in the intermediate
steps. We could have calculated <code>up_seconds</code> directly in the first query which
introduced <code>first_ts</code> and <code>last_ts</code>. That would look like this:</p>

<p>```sql
SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM
        age(
            least(cal.end_ts, uptime.end_ts), 
            CASE WHEN uptime.start_ts IS NOT NULL THEN
              greatest(uptime.start_ts, cal.start_ts)
            END
        )
    ),
    0
) AS up_seconds
</code></pre>

<p>FROM &mdash;&ndash; &hellip;
```</p>

<p>It&rsquo;s not for the weak stomach, but frankly speaking, neither is the subquery&hellip;</p>

<h2>Enough Nesting, <code>LATERAL</code> join save me!</h2>

<p>Lateral joins can give us the best of both worlds: reduced subquery nesting and
traceable computed values. We&rsquo;re going to move the initial computed values like
<code>first_ts</code> and <code>last_ts</code>, move them to a virtual table then <code>JOIN LATERAL</code> so
they can get their own table alias. We&rsquo;ll do it again for <code>up_seconds</code> and use
<code>first_ts</code> and <code>last_ts</code> from its sibling table.</p>

<p>```sql
SELECT</p>

<pre><code>t2.up_seconds
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
JOIN LATERAL (
  SELECT</p>

<pre><code>  -- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>) t1 ON true
JOIN LATERAL (
  &mdash; calculate uptime seconds for the time slice
  SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM age(last_ts, first_ts)),
    0
) AS up_seconds
</code></pre>

<p>) t2 ON true
```</p>

<p>This gives us the same results but without the deep nesting.</p>

<p>```plain</p>

<h2> up_seconds</h2>

<pre><code>      0
   2700
    900
      0
      0
   3600
</code></pre>

<p>&hellip;</p>

<pre><code>   3600
</code></pre>

<p>(48 rows)
```</p>

<p>What&rsquo;s great about this strategy is we can quickly choose which columns to see
as we build up the query.</p>

<p>```sql
SELECT
  t2.up_seconds
  &hellip;</p>

<p>&mdash; or &mdash;</p>

<p>SELECT
  t2.<em>,
  t1.</em>
```</p>

<p>Let&rsquo;s build up the final calculation using the same strategy:</p>

<p>```sql
SELECT
  t2.<em>,
  t3.</em>
FROM &hellip;
JOIN LATERAL (
  &mdash; calculate percentage between uptime seconds and available seconds
  &mdash; within the time slice
  SELECT</p>

<pre><code>up_seconds / cal_seconds AS up_pct
</code></pre>

<p>) t3 ON true
```</p>

<p>```plain
 up_seconds | up_pct
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;</p>

<pre><code>      0 |      0
   2700 |   0.75
    900 |   0.25
      0 |      0
</code></pre>

<p>&hellip;</p>

<pre><code>   3600 |      1
</code></pre>

<p>(48 rows)
```</p>

<h2>Plot the Hours</h2>

<p>Now we have all the computed data we need. Let&rsquo;s plot it as a cross tab (but not
actually use <a href="https://www.postgresql.org/docs/9.3/static/tablefunc.html"><code>crosstab</code></a>)</p>

<p>We&rsquo;ll need to consolidate the long list of data by <code>cal_date</code> and pivot the
<code>cal_hour</code> as a column and <code>up_pct</code> as a value. In case of overlapping uptimes
we&rsquo;ll be pessimists and choose the lowest or <code>min</code> uptime percentage.</p>

<p>The final query looks like:</p>

<p>```sql
SELECT</p>

<pre><code>cal_date,
max(CASE WHEN cal_hour = 0 THEN up_pct  END) AS hour_0,
max(CASE WHEN cal_hour = 1 THEN up_pct  END) AS hour_1,
max(CASE WHEN cal_hour = 2 THEN up_pct  END) AS hour_2,
max(CASE WHEN cal_hour = 3 THEN up_pct  END) AS hour_3,
max(CASE WHEN cal_hour = 4 THEN up_pct  END) AS hour_4,
max(CASE WHEN cal_hour = 5 THEN up_pct  END) AS hour_5,
max(CASE WHEN cal_hour = 6 THEN up_pct  END) AS hour_6,
max(CASE WHEN cal_hour = 7 THEN up_pct  END) AS hour_7,
max(CASE WHEN cal_hour = 8 THEN up_pct  END) AS hour_8,
max(CASE WHEN cal_hour = 9 THEN up_pct  END) AS hour_9,
max(CASE WHEN cal_hour = 10 THEN up_pct END) AS hour_10,
max(CASE WHEN cal_hour = 11 THEN up_pct END) AS hour_11,
max(CASE WHEN cal_hour = 12 THEN up_pct END) AS hour_12,
max(CASE WHEN cal_hour = 13 THEN up_pct END) AS hour_13,
max(CASE WHEN cal_hour = 14 THEN up_pct END) AS hour_14,
max(CASE WHEN cal_hour = 15 THEN up_pct END) AS hour_15,
max(CASE WHEN cal_hour = 16 THEN up_pct END) AS hour_16,
max(CASE WHEN cal_hour = 17 THEN up_pct END) AS hour_17,
max(CASE WHEN cal_hour = 18 THEN up_pct END) AS hour_18,
max(CASE WHEN cal_hour = 19 THEN up_pct END) AS hour_19,
max(CASE WHEN cal_hour = 20 THEN up_pct END) AS hour_20,
max(CASE WHEN cal_hour = 21 THEN up_pct END) AS hour_21,
max(CASE WHEN cal_hour = 22 THEN up_pct END) AS hour_22,
max(CASE WHEN cal_hour = 23 THEN up_pct END) AS hour_23
</code></pre>

<p>FROM (</p>

<pre><code>-- build virtual table of all hours between
-- a date range
SELECT
    start_ts,
    start_ts + interval '1 hour' AS end_ts
    FROM generate_series('2017-03-01'::date,
                         '2017-03-03'::timestamp - interval '1 hour',
                         interval '1 hour'
    ) AS t(start_ts)
) AS cal
</code></pre>

<p>LEFT JOIN (</p>

<pre><code>-- build virtual table of uptimes
SELECT *
FROM (
    VALUES
    ('2017-03-01 01:15:00-06'::timestamp, '2017-03-01 02:15:00-06'::timestamp),
    ('2017-03-01 08:00:00-06', '2017-03-01 20:00:00-06'),
    ('2017-03-02 19:00:00-06', null)
) AS t(start_ts, end_ts)
</code></pre>

<p>) AS uptime ON cal.end_ts > uptime.start_ts AND cal.start_ts &lt;= coalesce(uptime.end_ts, current_timestamp)
JOIN LATERAL (
  SELECT</p>

<pre><code>  -- will use `first_ts` and `last_ts` to calculate uptime duration
CASE WHEN uptime.start_ts IS NOT NULL THEN
    greatest(uptime.start_ts, cal.start_ts)
END                                               AS first_ts,
least(cal.end_ts, uptime.end_ts)                  AS last_ts,
date_trunc('day', cal.start_ts)::date             AS cal_date,
extract(hour from cal.start_ts)                   AS cal_hour,
extract(epoch from age(cal.end_ts, cal.start_ts)) AS cal_seconds
</code></pre>

<p>) t1 ON true
JOIN LATERAL (
  SELECT</p>

<pre><code>coalesce(
    extract(epoch FROM age(last_ts, first_ts)),
    0
) AS up_seconds
</code></pre>

<p>) t2 ON true
JOIN LATERAL (
  &mdash; calculate percentage between uptime seconds and available seconds
  &mdash; within the time slice
  SELECT
  up_seconds / cal_seconds AS up_pct
) t3 ON true
GROUP BY cal_date
```</p>

<p><code>plain
  cal_date  | hour_0 | hour_1 | hour_2 | hour_3 | ... | hour_23
------------+--------+--------+--------+--------+ ... +---------
 2017-03-01 |      0 |   0.75 |   0.25 |      0 | ... |       0
 2017-03-02 |      0 |      0 |      0 |      0 | ... |       1
(2 rows)
</code></p>

<h1>More than CTE and Cross Join</h1>

<p>This example only scratches the surface of <code>LATERAL</code>s super powers. On the
surface <code>LATERAL</code> can do things <code>CTE</code>, cross join, and <code>WINDOW</code> can do.
PostgreSQL describe <code>LATERAL</code> as:</p>

<blockquote><p>Subqueries appearing in FROM can be preceded by the key word LATERAL.
This allows them to reference columns provided by preceding FROM items.
(Without LATERAL, each subquery is evaluated independently and so cannot
cross-reference any other FROM item.)</p></blockquote>

<p>TL;DR &ndash; <code>LATERAL</code> allows subqueries to reference earlier tables.</p>

<h1>References</h1>

<ul>
<li><a href="https://www.postgresql.org/docs/9.6/static/queries-table-expressions.html#QUERIES-LATERAL">Postgres Lateral Joins</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Get Better At Anything]]></title>
    <link href="http://ddrscott.github.io/blog/2017/how-to-get-better-at-anything/"/>
    <updated>2017-02-07T05:30:06-06:00</updated>
    <id>http://ddrscott.github.io/blog/2017/how-to-get-better-at-anything</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/better.jpg" width="600" height="445" title="&lsquo;Better Title&rsquo;" ></p>

<!-- more -->


<h2>RTFM</h2>

<p><img src="/images/rtfm-wtfm.jpg" width="400" height="387" title="&lsquo;RTFM WTFM&rsquo;" ></p>

<ul>
<li>WTFM, Write The Flip'n Manual</li>
<li>Do a lightning talk about it :)</li>
</ul>


<h2>Make it Fun</h2>

<p><img src="/images/koala_trophy.jpg" title="&lsquo;Surprised Koala Trophy&rsquo;" ></p>

<ul>
<li>Gamification</li>
<li>Trophy anyone?</li>
<li>If it can&rsquo;t be made fun, make it fun.</li>
</ul>


<h2>Practice</h2>

<p><img src="/images/ive_practiced.jpg" title="&ldquo;I&rsquo;ve practiced a lot&rdquo;" ></p>

<ul>
<li>Slowly with intent</li>
<li>Pressure cycles: none, some, actual, intolerable.</li>
<li>The practice of practice deserves its own talk.</li>
</ul>


<h2>Better not good</h2>

<p><img src="/images/good_to_better.jpg" title="&ldquo;Good to Better Chart&rdquo;" ></p>

<ul>
<li>Good is the killer of better.</li>
<li>People tend to stop because good is unreachable.</li>
<li>People tend to stop after they&rsquo;re good enough.</li>
<li>If we aim to get better, we&rsquo;ll eventually be better than good.</li>
<li>Progressive goals. OMG! I forgot goal setting!</li>
</ul>


<h2>Learn, don&rsquo;t Memorize</h2>

<p><img src="/images/one_does_not_memorize_pi.jpg" title="&ldquo;One does not simply memorize PI&rdquo;" ></p>

<ul>
<li>Learning is understanding</li>
<li>Understanding is connecting the new thing to an old thing.</li>
<li>Computers memorize. You&rsquo;re not a computer.</li>
</ul>


<h2>Learn with others</h2>

<p><img src="/images/google_hug.jpg" title="&ldquo;Google Hug&rdquo;" ></p>

<ul>
<li>With the Internet you&rsquo;re never alone and always alone.</li>
<li>Actually talk with people!</li>
</ul>


<h2>Cheat</h2>

<p><img src="/images/inspect_source.jpg" title="&ldquo;One does not simply memorize PI&rdquo;" ></p>

<ul>
<li>If you&rsquo;re not cheating, you&rsquo;re not trying.</li>
<li>Reverse engineer the cheat, don&rsquo;t actually cheat!</li>
</ul>


<h1>How I got better at Vim</h1>

<ul>
<li><strong>RTFM</strong> &ndash; <code>:help</code></li>
<li><strong>WTFM</strong> &ndash; Blogging, figure out other people&rsquo;s problems :/</li>
<li><strong>Practice</strong> &ndash; Wrote stuff that wasn&rsquo;t needed immediately, my own notes.</li>
<li><strong>Don&rsquo;t Memorize</strong> &ndash; Vim has grammar like English. Oooh&hellip; Reconnection!</li>
<li><strong>Learn with Others</strong> &ndash; We have vim users, teach them (but don&rsquo;t let them know you&rsquo;re only one step ahead)</li>
<li><strong>Cheat</strong> &ndash; Look at other&rsquo;s Vimscript to figure out that cool thing they did.</li>
</ul>


<h2>What do you want to get better at next?!?</h2>

<ul>
<li>lightning talks?</li>
<li>Shuffling cards? (@devin)</li>
<li><a href="http://www.postgresql.org/docs/9.6/static/index.html">SQL?</a></li>
<li><a href="https://www.amazon.com/Drawing-Right-Side-Brain-Definitive/dp/1585429201">Drawing?</a></li>
<li><a href="http://www.pianofundamentals.com/book/en/chapter_1">Piano?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
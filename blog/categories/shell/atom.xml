<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: shell | @_ddrscott_]]></title>
  <link href="https://ddrscott.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="https://ddrscott.github.io/"/>
  <updated>2018-03-05T09:03:19-06:00</updated>
  <id>https://ddrscott.github.io/</id>
  <author>
    <name><![CDATA[Scott Pierce]]></name>
    <email><![CDATA[ddrscott@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FZF + WordNet = Dictionary]]></title>
    <link href="https://ddrscott.github.io/blog/2017/fzf-dictionary/"/>
    <updated>2017-06-12T13:30:00-05:00</updated>
    <id>https://ddrscott.github.io/blog/2017/fzf-dictionary</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/fzf_dictionary_demo.gif" width="707" height="412" title="&lsquo;FZF Dictionary&rsquo;" ></p>

<p><code>FZF + WordNet = Dictionary</code>. FZF is a fuzzy finding command line tool. WordNet
is a dictionary structured for developers. When married together, we can get
a snappy dictionary to help us find just the right word for any occasion.</p>

<!-- more -->


<h1>Install Required Program</h1>

<p>Before making our new shell function, lets install the required programs.</p>

<ol>
<li><a href="https://github.com/junegunn/fzf">https://github.com/junegunn/fzf</a></li>
<li><a href="http://wordnetweb.princeton.edu/perl/webwn">http://wordnetweb.princeton.edu/perl/webwn</a></li>
</ol>


<p>These directions are for Max OSX with <code>homebrew</code> installed. If you&rsquo;re on
a different system, read the docs from the sites above to get the programs for
your operating system.</p>

<p><code>sh
brew install fzf
brew cask install xquartz
brew install wordnet
</code></p>

<h2>FZF</h2>

<p>FZF stands for Fuzzy Finder. It is a program which enables the user to filter
a set of lines from standard in and feed those line back to standard out.
A basic example is: <code>find . | fzf</code>. This presents a list of all files in the
current working directory and prompts the user for input. As you type letters, the
list will narrow, keeping only the items matching the search criteria. After
selecting an entry from the list the line or lines chosen is printed to standard
out. It provides a nifty argument <code>--preview</code> which can execute a program and
display its output as an aside in the terminal. We&rsquo;ll write more about FZF in the
future.</p>

<h2>WordNet</h2>

<blockquote><p>WordNet is a large lexical database of English. Nouns, verbs, adjectives and
adverbs are grouped into sets of cognitive synonyms (synsets), each expressing
a distinct concept. Synsets are interlinked by means of conceptual-semantic
and lexical relations. The resulting network of meaningfully related words and
concepts can be navigated with the browser. WordNet is also freely and
publicly available for download. WordNet&rsquo;s structure makes it a useful tool
for computational linguistics and natural language processing.</p>

<p>WordNet superficially resembles a thesaurus, in that it groups words together
based on their meanings. However, there are some important distinctions.
First, WordNet interlinks not just word forms—strings of letters—but specific
senses of words. As a result, words that are found in close proximity to one
another in the network are semantically disambiguated. Second, WordNet labels
the semantic relations among words, whereas the groupings of words in
a thesaurus does not follow any explicit pattern other than meaning
similarity.</p></blockquote>

<p>Using WordNet we can find information similar to what is in a dictionary and
thesaurus combined.</p>

<p>Example output of looking up <code>happy</code> is:
```text
% wn happy -over</p>

<p>Overview of adj happy</p>

<p>The adj happy has 4 senses (first 2 from tagged texts)</p>

<ol>
<li>(37) happy &mdash; (enjoying or showing or marked by joy or pleasure; &ldquo;a happy smile&rdquo;; &ldquo;spent many happy days on the beach&rdquo;; &ldquo;a happy marriage&rdquo;)</li>
<li>(2) felicitous, happy &mdash; (marked by good fortune; &ldquo;a felicitous life&rdquo;; &ldquo;a happy outcome&rdquo;)</li>
<li>glad, happy &mdash; (eagerly disposed to act or to be of service; &ldquo;glad to help&rdquo;)</li>
<li>happy, well-chosen &mdash; (well expressed and to the point; &ldquo;a happy turn of phrase&rdquo;; &ldquo;a few well-chosen words&rdquo;)
```</li>
</ol>


<p><code>xquartz</code> is needed since the WordNet package also works in GUI mode. The GUI
app has a useful interface and could be more intuitive to use if you don&rsquo;t mind
clicking around. The GUI app can be started with <code>wnb</code>, but we&rsquo;re not here for
GUI stuff. Let&rsquo;s move on to making our terminal script.</p>

<h1>Shell Script</h1>

<p>The following 3 functions can be used individually and are helpful all on their
own. Add these directly into your shell profile or in a separate file and source
it from the profile.</p>

<p><code>fold</code> is normally a built in command. By default it adds newlines when text
overflows the terminal, but it doesn&rsquo;t do it in an easy to read fashion. The
default behavior can break in the middle of a word and assumes a terminal width
of 80 columns. Our <code>fold</code> function breaks at spaces and passes the whole
terminal width to it when no other arguments are provided.</p>

<p>```sh</p>

<h1>Default <code>fold</code> to screen width and break at spaces</h1>

<p>function fold {
  if [ $# -eq 0 ]; then</p>

<pre><code>/usr/bin/fold -w $COLUMNS -s
</code></pre>

<p>  else</p>

<pre><code>/usr/bin/fold $*
</code></pre>

<p>  fi
}
```</p>

<p><code>spell</code> is the FZF portion of our script. This fuzzy matches the built in Mac
dictionary with a preview window containing the WordNet overview of the selected
word.</p>

<p>```sh</p>

<h1>Use <code>fzf</code> against system dictionary</h1>

<p>function spell {
  cat /usr/share/dict/words | fzf &mdash;preview &lsquo;wn {} -over | fold&rsquo; &mdash;preview-window=up:60%
}
```</p>

<p>The <code>dic</code> script uses <code>spell</code> to help find a word then outputs WordNet&rsquo;s
definition.</p>

<p>```sh</p>

<h1>Lookup definition of word using <code>wn $1 -over</code>.</h1>

<h1>If $1 is not provided, we&rsquo;ll use the <code>spell</code> command to pick a word.</h1>

<p>#</p>

<h1>Requires:</h1>

<h1>brew install wordnet</h1>

<h1>brew install fzf</h1>

<p>function dic {
  if [ $# -eq 0 ]; then</p>

<pre><code>wn `spell` -over | fold
</code></pre>

<p>  else</p>

<pre><code>wn $1 -over | fold
</code></pre>

<p>  fi
}
```</p>

<p>Here&rsquo;s another demo of the <code>dic</code> function:
<img class="featured" src="/images/fzf_dict_demo2.gif" width="570" height="360" title="&lsquo;FZF Dictionary Demo 2&rsquo;" ></p>

<h1>Conclusion</h1>

<p>Gluing programs together with <code>fzf --preview</code> is fun. Let us know what other
recipes you come up with in the comments below.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GNU Screen]]></title>
    <link href="https://ddrscott.github.io/blog/2017/gnu-screen/"/>
    <updated>2017-06-01T13:30:00-05:00</updated>
    <id>https://ddrscott.github.io/blog/2017/gnu-screen</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/gnu-screen-featured.jpg" width="1024" height="488" title="&lsquo;GNU Screen Featured&rsquo;" ></p>

<blockquote><p>Screen is a full-screen window manager that multiplexes a physical terminal
between several processes, typically interactive shells.</p></blockquote>

<p>TL;DR &ndash; Screen keeps your ssh sessions alive on a host.</p>

<!-- more -->


<h2>Installation</h2>

<p>Most servers have <code>screen</code> installed already. If they don&rsquo;t it can be installed
via <code>apt-get install screen</code>, <code>yum install screen</code>, <code>brew install screen</code>. Sorry
Windows, try Remote Desktop.</p>

<h2>Startup</h2>

<p>Get a terminal on a remote host (or local) then run <code>screen</code></p>

<p><code>sh
screen
</code></p>

<p>If you&rsquo;re not brave, try <code>man screen</code> to read more about.</p>

<p>Once <code>screen</code> has started, you&rsquo;ll want to remember <code>&lt;C-a&gt;?</code>. That is how you get
the screen options menu. It&rsquo;s typed literal hold <code>CTRL</code> and press <code>a</code>. To quit
the <code>screen</code> app, type <code>exit</code>. To keep <code>screen</code> running, type <code>&lt;C-a&gt;d</code> to detach
from the program. To reattach to that session try <code>screen -x</code>.</p>

<h2>Options</h2>

<p>There are tons of options and they&rsquo;re best found by reading the <code>man</code> page or
Googling <code>gnu screen shortcuts</code>. Here&rsquo;s some of my favorites.</p>

<h3>Startup Flags</h3>

<ul>
<li><code>screen -DDR</code>. Force others of the current session and reattach yourself.</li>
<li><code>screen -x</code>. Reattach yourself, but allow others to stay in. This is
  cooperative mode. Good for pairing and much faster than GUI screen sharing.</li>
</ul>


<h3>Control Keys</h3>

<ul>
<li><code>&lt;C-a&gt;&lt;C-c&gt;</code>. Create a &ldquo;tab&rdquo; to have multiple sessions.</li>
<li><code>&lt;C-a&gt;&lt;C-a&gt;</code>. Toggle to previous session.</li>
<li><code>&lt;C-a&gt;&lt;Space&gt;</code>. Switch next session.</li>
<li><code>&lt;C-a&gt;a</code>. Send a literal <code>&lt;C-a&gt;</code> back to shell.</li>
</ul>


<h3>Config File and Pretty Colors</h3>

<p>It&rsquo;s easy to get lost in screen without a status line. So creating this file in
your home directory will help.</p>

<p><strong>~/.screenrc</strong>
<code>text
hardstatus alwayslastline
hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{= kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B} %m-%d %{W}%c %{g}]'
</code></p>

<p>This should give you a pretty statusline at the bottom of your terminal.
Here&rsquo;s what it looks like:
<img class="featured" src="/images/gnu-screen-statusline.jpg" width="1024" height="113" title="&lsquo;GNU Screen Statusline&rsquo;" ></p>

<h2>TMUX</h2>

<p>A strong competitor to <code>screen</code> is <code>tmux</code>. It has a more modern code base and is
actively maintained. The reason I personally don&rsquo;t use it is out of habit and
it&rsquo;s not installed everywhere. <code>screen</code> just works for my work flow.</p>

<h2>References</h2>

<ul>
<li><a href="https://www.gnu.org/software/screen/">https://www.gnu.org/software/screen/</a></li>
<li><a href="http://www.pixelbeat.org/lkdb/screen.html">http://www.pixelbeat.org/lkdb/screen.html</a></li>
<li><a href="http://aperiodic.net/screen/quick_reference">http://aperiodic.net/screen/quick_reference</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base16 Shell]]></title>
    <link href="https://ddrscott.github.io/blog/2017/base16-shell/"/>
    <updated>2017-04-13T13:30:00-05:00</updated>
    <id>https://ddrscott.github.io/blog/2017/base16-shell</id>
    <content type="html"><![CDATA[<p><img class="featured" src="/images/base16-featured.png" width="1024" height="558" title="&lsquo;Base16 Featured&rsquo;" ></p>

<p>After many years using the excellent Solarized color scheme, it has
started to feel stale. Sometimes I think the dark blueish tint brings
down my mood. Other times, I wonder what life could be like if I stared at more
cheerful colors. Thus starts my farewell from Solarized, and hello to
Base16.</p>

<!-- more -->


<p>From Base16&rsquo;s <a href="https://github.com/chriskempson/base16">Github README</a>:</p>

<blockquote><p>Base16 provides carefully chosen syntax highlighting and a default set of
sixteen colors suitable for a wide range of applications. Base16 is not a
single theme but a set of guidelines with numerous implementations.</p></blockquote>

<p>Which means after integrating into Base16 once, I&rsquo;ll have access to an
unlimited supply of themes in the future!</p>

<h2>Installation</h2>

<p>Base16 has perfect iTerm and shell integration. Once the repo was installed
locally, I called <code>base16_ocean</code> and was greeted by brand new palette. No iTerm
tweaking, no downloading this other thing and importing stuff into iTerm. It was
literally 2 steps performed in shell and then pick a theme.</p>

<p>Here&rsquo;s what you do. (FYI. This is pretty much copy/paste from their repo)</p>

<p>```sh</p>

<h1>1. clone the repo to <code>~/.config/base16-shell</code></h1>

<p>git clone <a href="https://github.com/chriskempson/base16-shell.git">https://github.com/chriskempson/base16-shell.git</a> ~/.config/base16-shell</p>

<h1>2. update ~/.bashrc or ~/.zshrc</h1>

<p>cat >> ~/.zshrc &lt;&lt;&lsquo;SH&rsquo;
BASE16_SHELL=$HOME/.config/base16-shell/
[ -n &ldquo;$PS1&rdquo; ] &amp;&amp; [ -s $BASE16_SHELL/profile_helper.sh ] &amp;&amp; eval &ldquo;$($BASE16_SHELL/profile_helper.sh)&rdquo;
SH
```</p>

<p>After you&rsquo;re done with those steps, start a new terminal session or source the
file, and start choosing a theme. Try <code>base16_ocean</code> to see what I&rsquo;m seeing. Try
<code>base16_&lt;tab&gt;</code> to see what other options you have available. To preview what
they look like before making a choice go to their website:
<a href="https://chriskempson.github.io/base16/.">https://chriskempson.github.io/base16/.</a></p>

<h2>Vim Integration</h2>

<p>Install plugin from <a href="https://github.com/chriskempson/base16-vim.">https://github.com/chriskempson/base16-vim.</a></p>

<p>Add the following to your <code>.vimrc</code>:</p>

<p><code>vim
if filereadable(expand("~/.vimrc_background"))
  let base16colorspace=256
  source ~/.vimrc_background
endif
</code></p>

<p><code>base16-shell</code> commands create the <code>~/.vimrc_background</code> file every time a
<code>base16_*</code> alias is used. This allows Vim to always stay synchronized with
shell which is AWESOME!</p>

<h2>Conclusion</h2>

<p>After cycling through everyone of the user created themes, I&rsquo;ve settled on
<code>base16_ocean</code> as my new home. I may get tired of it, I may not, but either way
I&rsquo;m just a shell command away from changing. Indecision has never been so easy.</p>
]]></content>
  </entry>
  
</feed>
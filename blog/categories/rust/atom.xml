<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rust | @_ddrscott_]]></title>
  <link href="https://ddrscott.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="https://ddrscott.github.io/"/>
  <updated>2018-03-22T07:02:20-05:00</updated>
  <id>https://ddrscott.github.io/</id>
  <author>
    <name><![CDATA[Scott Pierce]]></name>
    <email><![CDATA[ddrscott@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Rustic Journey Through Stream Stats]]></title>
    <link href="https://ddrscott.github.io/blog/2018/stream-stats-in-rust/"/>
    <updated>2018-03-17T02:45:00-05:00</updated>
    <id>https://ddrscott.github.io/blog/2018/stream-stats-in-rust</id>
    <content type="html"><![CDATA[<p><img class="featured" src="" width=1364 height=1078 alt="Stream Stats Demo" /></p>

<p>After playing <a href="/blog/2018/getting-rusty-with-vim/">Guessing Game</a> from the <a href="https://doc.rust-lang.org/book/first-edition/guessing-game.html">Rust Book</a> a few times, it was time to make something a little more substantial. We&rsquo;re going to create <code>stream_stats</code>, a CLI program which prints throughput statistics from <code>stdin</code> while redirecting through <code>stdout</code>. Think <code>tee</code> + <code>wc -l</code> + <code>watch</code> all at the same time.</p>

<p><strong>TL;DR</strong> &ndash; <code>cargo install stream_stats</code></p>

<!-- more -->


<p>Here is a quick demo of the program:</p>

<p><img src="https://ddrscott.github.io/images/stream_stats_demo.gif" width=745 height=250 alt="Stream Stats Gif" /></p>

<p>Today, I we&rsquo;ll build this program up in 6 steps smallish steps. The minimum requirement of this program was the live feedback as seen in the demo <em>and</em> minimal impact on the overall performance.</p>

<h2>Step 1 &ndash; Reproducing <code>cat</code> Inefficiently</h2>

<p>First step is to replicate <code>cat</code>. We&rsquo;ll do it as demonstrated by Rust&rsquo;s own <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">documentation</a>.</p>

<p>```rust
use std::io;</p>

<p>fn main() {</p>

<pre><code>let mut buffer = String::new();
while io::stdin().read_line(&amp;mut buffer).unwrap() &gt; 0 {
    print!("{}", buffer);
    buffer.clear();
}
</code></pre>

<p>}
```</p>

<blockquote><p>I&rsquo;m using <code>unwrap</code> to keep our program short and sweet.</p></blockquote>

<p>Save the code as <code>stream_stats.rs</code> and build it using <code>rustc -O stream_stats.rs</code>. This will
compile the program into <code>stream_stats</code>. We can now run the program with
<code>./stream_stats &lt; stream_stats.rs</code> or <code>cat stream_stats.rs | stream_stats</code>. This should output the source code we just wrote.</p>

<p>The program is sufficient for small streams, but will perform horribly on large files.</p>

<h2>Step 2 &ndash; Reproducing <code>cat</code> Efficiently with Buffering</h2>

<blockquote><p>It can be excessively inefficient to work directly with a Read instance. For example, every call to read on TcpStream results in a system call. A BufReader performs large, infrequent reads on the underlying Read and maintains an in-memory buffer of the results.</p>

<p>&mdash; <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">https://doc.rust-lang.org/std/io/struct.BufReader.html</a></p></blockquote>

<p>Lets add some buffer use to increase performance and get it near the speed of <code>cat</code>. Replace the contents of <code>stream_stats.rs</code> with the following, recompile, and run the program.</p>

<p>```rust
use std::io::{self, BufRead, BufReader, BufWriter, Write};</p>

<p>static READ_BUF_SIZE: usize = 1024 * 1024;</p>

<p>fn main() {</p>

<pre><code>let mut reader = BufReader::with_capacity(READ_BUF_SIZE, io::stdin());
let mut writer = BufWriter::new(io::stdout());
let mut buffer = vec![];

while reader.read_until(b'\n', &amp;mut buffer).unwrap() &gt; 0 {
    writer.write(&amp;buffer).unwrap();
    buffer.clear();
}
writer.flush().unwrap();
</code></pre>

<p>}
```</p>

<p>The exact difference is <a href="https://github.com/ddrscott/tutorial-stream_stats/commit/30da32426f7ac420f4660c168678341301c68648" target="_new">viewable on Github</a>.
Here&rsquo;s a one-liner which to help with the build/run cycle:</p>

<p><code>sh
rustc -O ./stream_stats.rs &amp;&amp; ./stream_stats &lt; stream_stats.rs
</code></p>

<p>For a few extra lines, we get a lot of performance. There are ways to get even more
performance, but it won&rsquo;t be worth the code complexity at this time.</p>

<h2>Step 3 &ndash; Count the Lines</h2>

<p>We&rsquo;re ready to start counting lines. We&rsquo;ll introduce a <code>struct</code> to hold a start
time and line count.</p>

<p>```rust
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::time::Instant;</p>

<p>static READ_BUF_SIZE: usize = 1024 * 1024;</p>

<p>struct Stats {</p>

<pre><code>started: Instant,
lines: usize,
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let mut reader = BufReader::with_capacity(READ_BUF_SIZE, io::stdin());
let mut writer = BufWriter::new(io::stdout());
let mut buffer = vec![];

let mut stats = Stats {
    started: Instant::now(),
    lines: 0,
};

while reader.read_until(b'\n', &amp;mut buffer).unwrap() &gt; 0 {
    writer.write(&amp;buffer).unwrap();
    stats.lines += 1;
    buffer.clear();
}
writer.flush().unwrap();
eprintln!("lines: {}, {:?}", stats.lines, stats.started.elapsed());
</code></pre>

<p>}
```</p>

<p>Again the exact difference is <a href="https://github.com/ddrscott/tutorial-stream_stats/commit/4131ec8daea852ec4641cbca9ba13775ff8679d5?diff=split" target="_new">viewable on Github</a>.</p>

<h2>Step 4 &ndash; Write to <code>/dev/tty</code></h2>

<p>Using <code>eprintln!</code> is easy, but bad practice for non-error output. The next step is moving the output to <code>/dev/tty</code>. As a reminder, we&rsquo;re also not using <code>println!</code> because we&rsquo;re reserving it for the original content piped from <code>stdin</code>.</p>

<p>```rust
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::time::Instant;</p>

<p>static READ_BUF_SIZE: usize = 1024 * 1024;</p>

<p>struct Stats {</p>

<pre><code>started: Instant,
lines: usize,
tty: File,
</code></pre>

<p>}</p>

<p>impl Stats {</p>

<pre><code>fn new(tty: &amp;str) -&gt; Stats {
    Stats {
        started: Instant::now(),
        lines: 0,
        tty: OpenOptions::new()
            .write(true)
            .append(true)
            .open(tty)
            .expect("Cannot open tty for writing!"),
    }
}
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let mut reader = BufReader::with_capacity(READ_BUF_SIZE, io::stdin());
let mut writer = BufWriter::new(io::stdout());
let mut buffer = vec![];
let mut stats = Stats::new("/dev/tty");

while reader.read_until(b'\n', &amp;mut buffer).unwrap() &gt; 0 {
    writer.write(&amp;buffer).unwrap();
    stats.lines += 1;
    buffer.clear();
}
writer.flush().unwrap();
writeln!(
    stats.tty,
    "lines: {}, {:?}",
    stats.lines,
    stats.started.elapsed()
).expect("Could not write to tty!");
</code></pre>

<p>}
```</p>

<p>Exact difference is <a href="https://github.com/ddrscott/tutorial-stream_stats/commit/e15502b23c1428f5ff86fdf6c6d791221e456992?diff=split" target="_new">viewable on Github</a>.</p>

<h2>Step 5 &ndash; Beautify Stats Output</h2>

<p>The display logic is going to get a little more complex. We want to move the string formatting code to a <code>fmt::Display</code> trait. We&rsquo;ll also add the kilobytes to the displayed stats.</p>

<p>```rust
use std::fmt;
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::time::Instant;</p>

<p>static READ_BUF_SIZE: usize = 1024 * 1024;
static CLEAR_LINE: &amp;str = &ldquo;\x1B[1G\x1B[2K&rdquo;;</p>

<p>struct Stats {</p>

<pre><code>started: Instant,
lines: usize,
bytes: usize,
tty: File,
</code></pre>

<p>}</p>

<p>impl Stats {</p>

<pre><code>fn new(tty: &amp;str) -&gt; Stats {
    Stats {
        started: Instant::now(),
        lines: 0,
        bytes: 0,
        tty: OpenOptions::new()
            .write(true)
            .append(true)
            .open(tty)
            .expect("Cannot open tty for writing!"),
    }
}
</code></pre>

<p>}</p>

<p>impl fmt::Display for Stats {</p>

<pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {

    let elapsed = self.started.elapsed();
    let seconds: f64 = elapsed.as_secs() as f64 + elapsed.subsec_nanos() as f64 * 1e-9;
    if seconds == 0.0 {
        return write!(f, "");
    }
    let kb = self.bytes as f64 / 1024 as f64;
    let kb_per_sec = kb / seconds;
    let lines_per_sec = self.lines as f64 / seconds;
    write!(
        f,
        "{}{:.1} sec | {:.0} kb [ {:.1}/s ] | {} lines [ {:.0}/s ]",
        CLEAR_LINE,
        seconds,
        kb,
        kb_per_sec,
        self.lines,
        lines_per_sec
    )
}
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let mut reader = BufReader::with_capacity(READ_BUF_SIZE, io::stdin());
let mut writer = BufWriter::new(io::stdout());
let mut buffer = vec![];
let mut stats = Stats::new("/dev/tty");

while reader.read_until(b'\n', &amp;mut buffer).unwrap() &gt; 0 {
    writer.write(&amp;buffer).unwrap();
    stats.lines += 1;
    stats.bytes += &amp;buffer.len();
    buffer.clear();
}
writer.flush().unwrap();
writeln!(&amp;stats.tty, "{}", &amp;stats).expect("Could not write to tty!");
</code></pre>

<p>}
```</p>

<p>Exact difference is <a href="https://github.com/ddrscott/tutorial-stream_stats/commit/d2c5ef1cfcffc6a54e4b669aae835051d262143d?diff=split" target="_new">viewable on Github</a>.</p>

<h2>Step 6 &ndash; Display the stats 10 times per second</h2>

<p>We&rsquo;re finally at the most useful part of the program. Viewing the stats while
the stream is still going.</p>

<p>For this task, we introduce a thread which loops forever sleeping a little and
waking to output the stats. Because of the thread, we need to use <code>Arc</code> to
safely tell Rust another thread is going to have a pointer to the stats object.</p>

<p>To be honest, I don&rsquo;t fully understand why I need to use <code>AtomicUsize</code>. I tried
to keep the <code>usize</code> variables would get errors regarding mutability. If someone
out there can remove the <code>AtomicUsize</code> without introducing <code>unsafe</code> please let
me know!</p>

<p>Here&rsquo;s the final code listing:</p>

<p>```rust
use std::fmt;
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread::{self, sleep};
use std::time::{Duration, Instant};</p>

<p>static READ_BUF_SIZE: usize = 1024 * 1024;
static CLEAR_LINE: &amp;str = &ldquo;\x1B[1G\x1B[2K&rdquo;;
static UPDATE_INTERVAL_MS: u64 = 100;</p>

<p>struct Stats {</p>

<pre><code>started: Instant,
lines: AtomicUsize,
bytes: AtomicUsize,
tty: File,
</code></pre>

<p>}</p>

<p>impl Stats {</p>

<pre><code>fn new(tty: &amp;str) -&gt; Stats {
    Stats {
        started: Instant::now(),
        lines: AtomicUsize::new(0),
        bytes: AtomicUsize::new(0),
        tty: OpenOptions::new()
            .write(true)
            .append(true)
            .open(tty)
            .expect("Cannot open tty for writing!"),
    }
}

fn add(&amp;self, buffer: &amp;Vec&lt;u8&gt;) {
    self.lines.fetch_add(1, Ordering::Relaxed);
    self.bytes.fetch_add(buffer.len(), Ordering::Relaxed);
}
</code></pre>

<p>}</p>

<p>impl fmt::Display for Stats {</p>

<pre><code>fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {

    let elapsed = self.started.elapsed();
    let seconds: f64 = elapsed.as_secs() as f64 + elapsed.subsec_nanos() as f64 * 1e-9;
    if seconds == 0.0 {
        return write!(f, "");
    }
    let bytes = self.bytes.load(Ordering::Relaxed) as f64;
    let lines = self.lines.load(Ordering::Relaxed) as f64;
    let kb = bytes / 1024 as f64;
    let kb_per_sec = kb / seconds;
    let lines_per_sec = lines / seconds;
    write!(
        f,
        "{}{:.1} sec | {:.0} kb [ {:.1}/s ] | {:.0} lines [ {:.0}/s ]",
        CLEAR_LINE,
        seconds,
        kb,
        kb_per_sec,
        lines,
        lines_per_sec
    )
}
</code></pre>

<p>}</p>

<p>fn main() {</p>

<pre><code>let mut reader = BufReader::with_capacity(READ_BUF_SIZE, io::stdin());
let mut writer = BufWriter::new(io::stdout());
let mut buffer = vec![];
let stats = Arc::new(Stats::new("/dev/tty"));

let stats_clone = stats.clone();
thread::spawn(move || loop {
    sleep(Duration::from_millis(UPDATE_INTERVAL_MS));
    write!(&amp;stats_clone.tty, "{}", &amp;stats_clone).expect("Could not write to tty!");
});

while reader.read_until(b'\n', &amp;mut buffer).unwrap() &gt; 0 {
    writer.write(&amp;buffer).unwrap();
    stats.add(&amp;buffer);
    buffer.clear();
}
writer.flush().unwrap();
writeln!(&amp;stats.tty, "{}", &amp;stats).expect("Could not write to tty!");
</code></pre>

<p>}
```</p>

<p>Exact difference is <a href="https://github.com/ddrscott/tutorial-stream_stats/commit/e0b51a9de1364bfe3becfac8b27040c62bf06ac2?diff=split" target="_new">viewable on Github</a>.</p>

<h2>Closing Thoughts</h2>

<p>I personally learned a lot assembling these steps and wish I did this <em>before</em>
publishing the <code>cargo</code> <a href="https://github.com/ddrscott/stream_stats">crate</a> of the same name.</p>

<p>Any suggestions, comments, and corrections welcome on this post or the final crate are welcome.
<a href="https://github.com/ddrscott/stream_stats">https://github.com/ddrscott/stream_stats</a></p>

<p>Thanks for learning with me!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Rusty with Vim]]></title>
    <link href="https://ddrscott.github.io/blog/2018/getting-rusty-with-vim/"/>
    <updated>2018-03-04T06:30:00-06:00</updated>
    <id>https://ddrscott.github.io/blog/2018/getting-rusty-with-vim</id>
    <content type="html"><![CDATA[<p><img class="featured" src="" width=1910 height=1436 alt="Vim Screenshot" /></p>

<p>After dabbing in Go and Crystal, I figured I&rsquo;d give Rust a try. Of course I
used Vim along the way. Here are some notes I compiled after my first session.</p>

<!-- more -->


<h1>Vim Setup</h1>

<p>There are 2 excellent Vim plugins which play nice with Rust. First is
<a href="https://github.com/rust-lang/rust.vim">https://github.com/rust-lang/rust.vim</a> which provides:</p>

<blockquote><p>&hellip; Rust file detection, syntax highlighting, formatting, Syntastic integration, and more.</p></blockquote>

<p>It has nearly 1k stars, one of which is from me, and it&rsquo;s triple the stars of
<code>rust-mode</code> for Emacs.</p>

<p>The second plugin is <a href="https://github.com/racer-rust/vim-racer">https://github.com/racer-rust/vim-racer</a> which provides omni-complete and jump to definition. Both features are good enough that I don&rsquo;t need to use ctags. I&rsquo;ve in fact overridden several default Vim mappings with <code>vim-racer</code> implementations:</p>

<p><code>vim
au FileType rust nmap &lt;silent&gt; &lt;C-]&gt; &lt;Plug&gt;(rust-def)
au FileType rust nmap &lt;silent&gt; &lt;C-w&gt;&lt;C-]&gt; &lt;Plug&gt;(rust-def-vertical)
au FileType rust nmap &lt;silent&gt; &lt;C-w&gt;} &lt;Plug&gt;(rust-def-split)
au FileType rust nmap &lt;silent&gt; &lt;C-k&gt; &lt;Plug&gt;(rust-doc)
</code></p>

<h1>Rust Experience</h1>

<p>The featured image is an implementation of a number guessing game. The game is
from the Rust Tutorial Guide at
<a href="https://doc.rust-lang.org/book/first-edition/guessing-game.html.">https://doc.rust-lang.org/book/first-edition/guessing-game.html.</a> I followed the
guide sentence by sentence, line by line, and everything worked without
additional troubleshooting sessions. Good Job @rustlang!</p>

<p>I massaged the code a little more to fool around and came up with the code in
the featured screen shot. The source is available in this <a href="https://gist.github.com/ddrscott/991a329b7f1c1f7682da5e4c24cdecc5">gist</a>. It&rsquo;s not the most exciting code I&rsquo;ve
ever written, but possibly the most painless of the new languages I&rsquo;ve tried.</p>

<p>When I came across some confusing language decisions. I posted a tweet about it:</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Rust has clever tuple indexing, but square brackets would have been fine. What&#39;s wrong with `tuple[0]`? <a href="https://twitter.com/hashtag/rustlang?src=hash&amp;ref_src=twsrc%5Etfw">#rustlang</a> <a href="https://t.co/E0VY70zxuV">pic.twitter.com/E0VY70zxuV</a></p>&mdash; Scott Pierce (@_ddrscott_) <a href="https://twitter.com/_ddrscott_/status/969968042414366720?ref_src=twsrc%5Etfw">March 3, 2018</a></blockquote>


<p> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>@rustlang responded quickly with insightful information. They&rsquo;re totally getting
the Raving Fan Award this weekend!</p>

<h1>Conclusion</h1>

<p>Rust is worth pursing with or without Vim. The feedback from the compiler
and runtime errors is clear. The
<a href="https://github.com/racer-rust/vim-racer">racer-rust</a> completion utility gives
all IDE super powers. And finally, I hear it&rsquo;s a pretty good language, too.  <a href="https://www.rust-lang.org">https://www.rust-lang.org</a></p>
]]></content>
  </entry>
  
</feed>